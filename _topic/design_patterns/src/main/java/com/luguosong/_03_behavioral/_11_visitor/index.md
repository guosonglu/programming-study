---
layout: note
title: 访问者（Visitor）
nav_order: 110
parent: 行为型模式
grand_parent: 设计模式
create_time: 2023/6/20
---

# 意图

将业务的`实际操作`剥离到访问者类中, 使得业务的`实际操作`与`数据结构`分离, 从而可以在不修改数据结构的前提下,
通过增加新的访问者类来实现新的业务操作.

# 结构

![](https://cdn.jsdelivr.net/gh/luguosong/images@master/blog-img/202306201424586-%E8%AE%BF%E9%97%AE%E8%80%85%E7%BB%93%E6%9E%84.png)

1. `访问者（Visitor）`接口声明了一系列以对象结构的具体元素为参数的访问者方法。如果编程语言支持重载，这些方法的名称可以是相同的，但是其参数一定是不同的。
2. `具体访问者（Concrete Visitor）`会为不同的具体元素类实现相同行为的几个不同版本。
3. `元素（Element） `接口声明了一个方法来“接收” 访问者。该方法必须有一个参数被声明为访问者接口类型。
4. `具体元素（Concrete Element）`必须实现接收方法。
   该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。请注意，即使元素基类实现了该方法，所有子类都必须对其进行重写并调用访问者对象中的合适方法。
5. `客户端（Client）`通常会作为集合或其他复杂对象（例如一个组合树）的代表。 客户端通常不知晓所有的具体元素类，因为它们会通过抽象接口与集合中的对象进行交互。

# 示例

{% highlight java %}
{% include_relative VisitorExample.java %}
{% endhighlight %}

# 双分派

## 静态类型和实际类型

```java
import java.util.HashMap;
import java.util.Map;

class Demo {
    public static void main(String[] args) {
        /*
         * Map是静态类型，也叫明显类型
         * HashMap是实际类型
         * */
        Map<String, String> map = new HashMap<>();
    }
}
```

## 分派

`分派`:根据`对象类型`对`方法`进行选择称为。

## 静态分派

发生在编译时期，方法重载即是静态分派。

## 动态分派

发生在运行时期，动态的置换调某个方法。方法的重写支持动态分派，即`多态`。

## 双分派

双分派是一个允许在重载时使用动态绑定的技巧。

`双分派`=`静态分派`+`动态分派`

- `元素`对象通过`动态分派`将自己传递给访问者对象，从而让`访问者`对象能够处理元素对象的`实际类型`(这也是访问者中静态分派实现的基础)。
- `访问者`对象通过`静态分派`决定使用哪个重载版本的访问者方法。

`访问者`模式实现了`双分派`。尽管访问者模式基于双分派的原则创建， 但这并不是其主要目的。
`访问者`的目的是让你能为整个类层次结构添加`外部`操作， 而无需修改这些类的已有代码。
