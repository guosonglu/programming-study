---
layout: note
title: 外观模式
nav_order: 50
parent: 结构型模式
grand_parent: 设计模式
create_time: 2023/5/5
---

# 意图

为子系统中的`一组接口`提供一个`一致的界面`

定义了一个`高层接口`，这个接口使得`程序库`、`框架`或其他`复杂类`更加容易使用。

# 结构

![](https://cdn.jsdelivr.net/gh/guosonglu/images@master/diagrams/design-pattern/structural/facade/%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.svg)

![](https://cdn.jsdelivr.net/gh/guosonglu/images@master/blog-img/20230505143135.png)

1. `外观（Facade）`提供了一种访问特定子系统功能的便捷方式，
   其了解如何重定向客户端请求，知晓如何操作一切活动部件。
2. `创建附加外观（Additional Facade）`类可以避免多种不相关
   的功能污染单一外观，使其变成又一个复杂结构。客户端和
   其他外观都可使用附加外观。
3. `复杂子系统（Complex Subsystem）`由数十个不同对象构成。
   如果要用这些对象完成有意义的工作，你必须深入了解子系
   统的实现细节，比如按照正确顺序初始化对象和为其提供正
   确格式的数据。
   子系统类不会意识到外观的存在，它们在系统内运作并且相
   互之间可直接进行交互。
4. `客户端（Client）`使用外观代替对子系统对象的直接调用。

# 适用场景

- `如果你需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式。`子系统通常会随着时间的推进变得越来越复杂。即便是应用了设计模式，通常你也会创建更多的类。尽管在多种情形中子系统可能是更灵活或易于复用的，但其所需的配置和样板代码数量将会增长得更快。为了解决这个问题，外观将会提供指向子系统中最常用功能的快捷方式，能够满足客户端的大部分需求。
- `如果需要将子系统组织为多层结构，可以使用外观。`创建外观来定义子系统中各层次的入口。你可以要求子系统仅使用外观来进行交互，
