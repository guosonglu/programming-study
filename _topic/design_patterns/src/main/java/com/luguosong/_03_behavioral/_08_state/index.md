---
layout: note
title: 状态（State）
nav_order: 80
parent: 行为型模式
grand_parent: 设计模式
create_time: 2023/6/15
---

# 意图

将状态和行为分离，使得增加状态时不需要在每个行为中修改代码进行判断。

将原本不同状态需要通过`if-else`判断的逻辑，转移到状态类中，使得状态类可以独立变化，而不会影响到其他状态类。

{: .note}
> 行为和状态并没有一一对应，有些行为将改变状态，有些行为则不会改变状态。

# 不使用状态模式

代码：

{% highlight java %}
{% include_relative WithoutStateExample.java %}
{% endhighlight %}

结构：

```shell
====初始状态================================
当前情况-->库存: 5 颗口香糖，机器状态为 等待投币

====第一轮投币================================
你投入了一个硬币
你转动了手柄...
一颗口香糖从出口滚出来
当前情况-->库存: 4 颗口香糖，机器状态为 等待投币

====第二轮投币================================
你投入了一个硬币
退还硬币
你转动了手柄，但没有投入硬币
当前情况-->库存: 4 颗口香糖，机器状态为 等待投币

====第三轮投币================================
你投入了一个硬币
你转动了手柄...
一颗口香糖从出口滚出来
你投入了一个硬币
你转动了手柄...
一颗口香糖从出口滚出来
你还没有投入硬币
当前情况-->库存: 2 颗口香糖，机器状态为 等待投币

====第四轮投币================================
你投入了一个硬币
无法再投入另一个硬币
你转动了手柄...
一颗口香糖从出口滚出来
你投入了一个硬币
你转动了手柄...
一颗口香糖从出口滚出来
糟糕，口香糖售罄！
无法投入硬币，机器已售罄
你转动了手柄，但口香糖已售罄
当前情况-->库存: 0 颗口香糖，机器状态为 售罄
```

# 结构

![](https://cdn.jsdelivr.net/gh/luguosong/images@master/blog-img/202306151842530-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png)

1. `上下文（Context）`保存了对于一个具体状态对象的引用，并会将所有与该状态相关的工作委派给它。上下文通过状态接口与状态对象交互，且会提供一个设置器用于传递新的状态对象。
2. `状态（State）`接口会声明特定于状态的方法。这些方法应能被其他所有具体状态所理解，因为你不希望某些状态所拥有的方法永远不会被调用。
3. `具体状态（Concrete States）`会自行实现特定于状态的方法。为了避免多个状态中包含相似代码，你可以提供一个封装有部分通用行为的中间抽象类。状态对象可存储对于上下文对象的反向引用。状态可以通过该引用从上下文处获取所需信息，并且能触发状态转移。
4. 上下文和具体状态都可以设置上下文的下个状态，并可通过替换连接到上下文的状态对象来完成实际的状态转换。

# 示例

{% highlight java %}
{% include_relative StateExample.java %}
{% endhighlight %}
