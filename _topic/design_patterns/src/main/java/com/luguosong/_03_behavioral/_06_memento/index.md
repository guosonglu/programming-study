---
layout: note
title: 备忘录（Memento）
nav_order: 110
parent: 行为型模式
grand_parent: 设计模式
create_time: 2023/6/20
---

# 意图

提供一种状态恢复机制，让用户能够回到某个历史的状态。

# 结构（黑箱）

![](https://cdn.jsdelivr.net/gh/luguosong/images@master/blog-img/202306201842304-%E5%A4%87%E5%BF%98%E5%BD%95%E7%BB%93%E6%9E%84.png)

1. `原发器（Originator）`类可以生成自身状态的快照，也可以在需要时通过快照恢复自身状态。
2. `备忘录 （Memento）` 是原发器状态快照的值对象 （value object）。通常做法是将备忘录设为不可变的，并通过构造函数一次性传递数据。
3. `负责人（Caretaker）`仅知道`何时`和`为何`捕捉原发器的状态，以及何时恢复状态。

   负责人通过保存备忘录栈来记录原发器的历史状态。当原发器需要回溯历史状态时，负责人将从栈中获取最顶部的备忘录，并将其传递给原发器的`恢复（restoration）`方法。
4. 在该实现方法中，备忘录类将被嵌套在原发器中。这样原发器就可访问备忘录的成员变量和方法，即使这些方法被声明为私有。另一方面，负责人对于备忘录的成员变量和方法的访问权限非常有限：它们只能在栈中保存备忘录，而不能修改其状态。

# 结构（白箱）

![](https://cdn.jsdelivr.net/gh/luguosong/images@master/blog-img/202306202352328-%E5%A4%87%E5%BF%98%E5%BD%95%E7%99%BD%E7%AE%B1%E6%A8%A1%E5%BC%8F.png)

1. 在没有嵌套类的情况下，你可以规定负责人仅可通过明确声明的中间接口与备忘录互动，该接口仅声明与备忘录元数据相关的方法，限制其对备忘录成员变量的直接访问权限。
2. 另一方面，原发器可以直接与备忘录对象进行交互，访问备忘录类中声明的成员变量和方法。这种方式的缺点在于你需要将备忘录的所有成员变量声明为公有。

# 示例

{% highlight java %}
{% include_relative MementoExample.java %}
{% endhighlight %}
